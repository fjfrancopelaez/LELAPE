\chapter{How to use LELAPE}
\section{Formatting input data}
%
You are supposed to have performed experiments on some memory element. Tests were performed as:
\begin{itemize}
	\item \textbf{Static}: The device was written, sent to standby mode, irradiated and eventually read. The content after the irradiation was compared to the initially writing.
	\item \textbf{Pseudostatic}: Similar to static ones, but standby intervals are shorter than the irradiation time and the memory is read several times during the irradiation. Usually, flipped bits are corrected on the flight.
\end{itemize}

In both cases, the researcher saves information about the bitfilps: Word address, read content, 
In order to use LELAPE, radiation test data must be converted to a matrix with three or four columns. The meaning of the columns is the following:
\begin{itemize}
	\item First Column: Word Address where bitflips were observed.
	\item Second Column: Content in the word address after the radiation tests.
	\item Third Column: Content in the word address before the irradiation.
	\item Fourth Column: In pseudostatic tests, cycle in which the bitflip was observed. This column can be omitted in the static tests or replaced by a column full of ones. 
\end{itemize} 

LELAPE needs this elements to be converted to a UInt32 matrix\footnote{In Julia, typing variable is optional but encouraged to speed up calculations.} so it is important that all the elements of the matrix, including the cycle label, are in this format or, at least, in some kind of integer. This makes dangerous labelling the fourth column with words or letters. 

A simple solution consists in grouping the data results in CSV format and read this text file with \texttt{readdlm}, included in the \text{DelimitedFiles} package. In the Jupyter folder, you can see some examples that can guide you to adapt your own data. One advantage of this function is that it can automatically convert the data to the required format, as shown in the Jupyter notebooks.

\section{Setting up the analysis}
%
Before starting the analysis, we must define some additional variables to indicate the software how to proceed. These variables are the followong:
%
\begin{itemize}
	\item \textbf{LA}: Variable in integer format. It indicates the memory size in words (not in bits!). It is often a power of 2.
	\item \textbf{WordWidth}: Also an integer, it indicates the number of bits per word. Typically 8, 16, 32 but other values are possible.
	\item \textbf{Operation}: A string variable to indicate the mathematical operation used to create the DV set. So far, only two options are implemented:
	\begin{itemize}
		\item \textit{XOR}: Addresses are xored bit to bit. This mode is set with the \texttt{``XOR''} value.
		\item \textit{Positive subtraction}: The absolute value of the difference of addresses is returned. It is marked with \texttt{"POS"}. 
	\end{itemize}
	In practice, we have observed that the former is appropriate for SRAMs and the latter for FPGAs. However, this idea may be erroneous due to the use of few and partial radiation test data.
	%
	\item \textbf{UsePseudoAddress}: The pseudoaddress is defined as follows: let us suppose that we have observed a bitflip in the $k$-th position of the $NWA$-th word address, The word width is $W$ and $k=0$ corresponds to the least significant bit, $W-1$ to the most significant one. Hence, the pseudoaddress of the bitflip is:
	\[
		PSA = NWA\cdot W + k
	\]
	This value is full of meaning in FPGAs since just returns the position of the cell in the bitflips. It is completly artificial in some SRAMs but somehow analysis using the pseudoaddress instead of the word address are more accurate and efficient. 
	
	The researcher can set this variable to \texttt{true} or \texttt{false} at will.
	%
	\item \textbf{KeepCycles}: In pseudostatic tests, this boolean variable indicates that the system must use the information about the cycles (fourth column) or just using the set of data as a whole. 
	%
	\item \textbf{TraceRuleLength}: This an integer variable with 1,2 or 3 as allowed values. LELAPE looks for anomalously repeated elements in the DV set with very few ones in binary representation. The user can decide if looks for elements with 1, 2 or 3 ones or less and include them as candidates to detect pairs. 
	%
	\item \textbf{$\varepsilon$}: A float number always positive but close to 0. If the expected number of elements repeated $k$ times in the DV set is lower than $\varepsilon$, we must consider this number of repetitions impossible. If higher, we determine than at least an element can appear $k$ times just due to randomness. Default value is 0.05.
	
	A very low value of $\varepsilon$ will exclude false positive but also genuine values relating pair of addresses in an MCU. On the contrary, if it is chosen too low, false positives might be taken as good ones.
	%
	\item \textbf{LargestMCUSize}: During the search of critical DV values, LELAPE starts to group addresses in provisional MCUs that grow large and large as new possible critical DV values are tested. Unfortunately, sometimes this process does not find a stable solution and goes on looking for it despite being unrealistic. This parameter is used to stop the calculation since it informs the software of not considering MCUs with more than \textit{LargestMCUSize} addresses. By default, it is set to 200.
\end{itemize}

 \section{Functions in the module}
 
 \subsection*{ConvertToPseudoADD}
 \begin{itemize}
 	\item \textbf{Arguments}: 
 		\begin{itemize}
 			\item \textit{Method 1: }\textbf{DATA}::Array\{UInt32\}, \textbf{WordWidth}::Int
 			\item \textit{Method 2: }\textbf{DATA}::Array\{UInt32\}, \textbf{WordWidth}::Int, \textbf{KeepCycle}::Bool
 		\end{itemize}
 	\item   \textbf{Output}: Array\{UInt32, 2\}, or Matrix\{UInt32\}.
 	\item  This function looks for the flipped bits between words in the same row but in the second
 	 and third columns of the DATA matrix. It does not matter if there are several bitflips, since they are independently coundted. 
 	 The pseudoaddress  of each bitflip, defined as \[\text{WORDADDRESS}\times\text{Wordwith}+\text{Bitposition}\] is returned as the first column of the output.
 	
 	 If there is information about the different cycles, it can be kept in the optional second column in the output with the condition of declaring \textbf{KeepCycle} true. If cycle information is absent, the second column is filled with 1s.
 	
 \end{itemize}

\subsection*{ExtractFlippedBits}
\begin {itemize}
	\item \textbf{Arguments}:
		\begin{itemize}
			\item \textit{Method 1: }\textbf{WORD}::UInt32, \textbf{PATTERN}::UInt32, \textbf{Wordwidth}::Int
			\item \textit{Method 2: }\textbf{WORD}::UInt16, \textbf{PATTERN}::UInt16, \textbf{Wordwidth}::Int
			\item \textit{Method 3: }\textbf{WORD}::UInt8, \textbf{PATTERN}::UInt8, \textbf{Wordwidth}::Int
		\end{itemize}
	\item \textbf{Output}: :Array\{Int,1\}, or Vector\{Int\}
	\item This function allows discovering the position of different bits between WORD
	 and PATTERN. It also verifies that both values are coherent with the \textbf{Wordwidth},
	 meaning that neither of them are higher than \(2^{Wordwidth}-1\). A vector, never larger than \textbf{Wordwidth} is returned. If \textbf{WORD} and \textbf{PATTERN} are equal, the output is a void vector.
\end{itemize}

\subsection*{CheckMBUs}

TBD

\subsection*{DetectAnomalies\_SelfConsis}
\begin{itemize}
	\item \textbf{Arguments}:
	\begin{itemize}
		\item  \textit{Method 1: }\textbf{DATA}::Array\{UInt32, 2\}, 
		\textbf{WordWidth}::Int,
		\textbf{LN0}::Int,
		\textbf{Operation}::String,
		\textbf{UsePseudoADD}::Bool,
		\textbf{KeepCycle}::Bool,
		\textbf{\(\varepsilon\)}::AbstractFloat,
		\textbf{LargestMCUSize}::Int
		%
		\item  \textit{Method 2: }\textbf{DATA}::Array\{UInt32, 2\}, 
		\textbf{WordWidth}::Int,
		\textbf{LN0}::Int,
		\textbf{Operation}::String,
		\textbf{UsePseudoADD}::Bool,
		\textbf{KeepCycle}::Bool,
		\textbf{\(\varepsilon\)}::AbstractFloat
		%
		\item  \textit{Method 3: }\textbf{DATA}::Array{UInt32, 2}, 
		\textbf{WordWidth}::Int,
		\textbf{LN0}::Int,
		\textbf{Operation}::String,
		\textbf{UsePseudoADD}::Bool,
		\textbf{KeepCycle}::Bool
	\end{itemize}
	%
	\item \textbf{Output: } Array\{UInt32, 2\}	
	%
	\item This function will calculate the anomalies in the set of addresses using the SelfConsistency principle.

	 First of all, let us know the inputs:
	 \begin{itemize}
	
		\item   \textbf{DATA}: A matrix with 3 or 4 columns. 
			 \begin{itemize}
			 	\item The first one contains the word addresses in UInt32 format.
			 	\item The second one shows the content read in the memory after the irradiation.
			 	\item The third one, the pattern that should be inside.
			 	\item  The fourth one is optional and shows the namber of the read cycle if the   memory was read and corrected several times during the irradiation.
			 \end{itemize}
		\item   \textbf{WordWidth}: The size of each word in bits, usually 8, 16. 32, etc.
		\item   \textbf{LN0}: The memory size in words (not in bits!!!). In many cases, \(2^N\).
		\item   \textbf{Operation}: A string variable to indicate the preferred operation to calculate
	    the DVSET. Only two operations are allowed: 
	    \begin{itemize}
	    	\item "XOR": XORing bit to bit.
	    	\item "POS": abs(a-b)
	    \end{itemize}
		\item  \textbf{UsePseudoADD}: A boolean variable. It allows to indicate that the user wants to user word addresses (false). If true, a pseudoaddress is assigned to each bit and calculated
	    as \(\text{WORADDRESS}\times\text{WordWidth} + \text{BitPosition}\). Full of sense in FPGA since it is just the position   of the bit in the bitstream, it has not physical interpretation in memories BUT works!!!!
		\item   \textbf{KeepCycle}: If true, the function looks for the fourth column and uses it to calculate the DVSet.
		\item   \textbf{\(\varepsilon\)}: A small positive integer number to determine the threshold that defines when a number of repetitions are impossible to occur. Set by default to 0.05 if not provided among the input arguments.
		\item  \textbf{LargestMCUSize}: This value indicates the largest possible size for MCUs. It has not physical sense  and is only used to stop the program if unreallistic events occur. Set to 200 if not given as an input.
	
	   The funcion return an \(N\times 2\) UInt32 matrix. The first column contains the anomalously repeated values of the DV SET compatible with the SelfConsistency test. The second one contains the number of times they appear in the DV set. Due to format integrity reasons, this column is expressed in unnatural UInt32 format. 
	  
	  It is advisable a latter conversion into Int to make this column more readable.
	\end{itemize}
\end{itemize}
\subsection*{DetectAnomalies\_Shuffle\_Rule}
 TBD
 %
 